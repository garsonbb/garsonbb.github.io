<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>STM32 on Garson's Blog</title><link>https://garnote.top/tags/stm32/</link><description>Recent content in STM32 on Garson's Blog</description><generator>Hugo</generator><language>zh-hans</language><copyright>Garson</copyright><lastBuildDate>Wed, 26 May 2021 00:16:00 +0000</lastBuildDate><atom:link href="https://garnote.top/tags/stm32/index.xml" rel="self" type="application/rss+xml"/><item><title>解决多种原因导致的STM32芯片被锁定</title><link>https://garnote.top/post/stm32_locked/</link><pubDate>Wed, 26 May 2021 00:16:00 +0000</pubDate><guid>https://garnote.top/post/stm32_locked/</guid><description>stm32cubeMX中Debug方式设置错误导致锁定芯片 昨天用clion和stm32cubeMX调试。创建好Project之后，忘记在cubeMX，SYS选项卡中选择DEBUG为Serial Wire。然后直接在clion中下载程序。然后下载失败，芯片锁了。我的daplink和jlink都认不出来了。
购买到二手拆机片 这段时间，芯片价格涨价。买了几个二手拆机片，都是设置了只读，或者是还有程序在芯片里跑。我直接用daplink下载程序，只是提示下载失败。我不太懂DAPLink的使用。插上JLink后，在Keil中的Debug选项卡中识别到芯片之后，弹出： 出现这个，应该有这几种可能
芯片坏了 芯片读保护 芯片焊接有问题，NRST复位按钮那里有问题 解决方法 下载安装JLink的工具包https://www.segger.com/downloads/jlink/#J-LinkSoftwareAndDocumentationPack Debug方式设置错误导致锁定芯片 打开J-Flash Lite选择对应芯片，我的是STM32F103C8。之后，点Erase Chip。是不行的，似乎不能Reset芯片。 所以之后手动，点了Erase Chip，快速多次按PCB上的Reset按钮，提示Reset 🆗马上停下，这样就可以清空芯片。芯片也可以被识别了。
购买到二手拆机片 打开J-Flash V6.98a，Create new project 选择你对应的芯片 连接MCU 擦除芯片 先解锁芯片，再擦除。 一般到这就修好了，不然可能芯片坏了（电路没焊接错的话） 其他情况 打开STM32 Unlock 看到命令行窗口，输入你使用的芯片系列对应的数字。</description></item><item><title>使用CLion开发-STM32F4开启FPU并调用DSP库</title><link>https://garnote.top/post/94/</link><pubDate>Wed, 06 Jan 2021 12:47:00 +0000</pubDate><guid>https://garnote.top/post/94/</guid><description>下载DSP库 可以在ST官网下载 可以在Arm这下载最新版本的库https://github.com/ARM-software/CMSIS_5/releases 下载.pack，用压缩软件打开查看 进入CMSIS\DSP\Lib\GCC\提取libarm_cortexM4lf_math.a 进入CMSIS\DSP\Include\提取arm_math.h 在CMakeList.txt中添加链接 1include_directories(包含arm_math.h的文件夹路径) 2target_link_libraries(${PROJECT_NAME}.elf ${CMAKE_SOURCE_DIR}/...你自己的路径/libarm_cortexM4lf_math.a) 开启FPU 只需要在CMakeLists中#Uncomment for hardware floating point下的配置去除注释就可以了，不需要额外的define标签。 之所以不用像Keil一样额外的define，因为在stm32f407xx.h(2017)中第52行默认是已经是 #define __FPU_PRESENT 1U， 而且在core_cm4.h(V5.0.8)中第100行，在__GNUC__默认是 #define __FPU_USED 1U</description></item><item><title>Ubuntu下使用Clion+STM32CubeMx+OpenOCD进行开发</title><link>https://garnote.top/post/stm32_clion/</link><pubDate>Fri, 13 Dec 2019 18:15:00 +0000</pubDate><guid>https://garnote.top/post/stm32_clion/</guid><description>Clion 下载地址 利用edu邮箱可以申请免费授权，一年一申。传送门 解压之后在源码目录执行sudo ./clion-2019.3/bin/clion.sh安装。 STM32CubeMx 安装jre.sudo apt install default-jre. 下载STM32CubeMx. 解压之后进入目录执行sudo ./SetupSTM32CubeMX-5.4.0.linux安装(要先给这个文件加上可执行权限)。 arm-none-eabi-gcc 下载arm-none-eabi-gcc 解压到/usr/lib/gcc. vi /etc/profile 在最后一行加入export PATH=$PATH:/usr/lib/gcc/gcc-arm-none-eabi-9-2019-q4-major/bin注意修改目录位置. 重启生效PATH OpenOCD OpenOCD代码托管在这里，选择最新版本下载https://sourceforge.net/projects/openocd/files/openocd/ 解压，进入源码目录 ./configure -help可查看帮助 ./bootstrap生成配置文件 ./configure --enable jlink添加jlink支持，可能会提示缺少什么库，按提示安装 sudo make &amp;amp;&amp;amp; make install安装。重启生效PATH 在源码目录下sudo cp contrib/60-openocd.rules /etc/udev/rule.d/ 不进行这部操作的话，在非root用户下运行Clion时，Clion会无权访问调试器。 最后 运行Clion，在Plugins中搜索stm32并安装第一个插件，重启Clion。New Project 选STM32CubeMX。在STM32CubeMX的Project Settings中，将Toolchain/IDE选成SW4STM32。最后Generate Code. Enjoy it.</description></item><item><title>stm32官方资源的一些记录</title><link>https://garnote.top/post/stm32_source/</link><pubDate>Fri, 28 Jun 2019 23:40:00 +0000</pubDate><guid>https://garnote.top/post/stm32_source/</guid><description> stm32芯片封装-&amp;gt;点我点我 需要用Ultra Librarian转为常见的Cendence、Altium、Pads格式。 stm32芯片的固件库-&amp;gt;传送门 keil .pack 传送门</description></item></channel></rss>